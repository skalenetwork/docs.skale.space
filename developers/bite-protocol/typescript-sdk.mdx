---
title: "BITE JS/TS SDK"
description: "SDK for JavaScript and Typescript developers to build encrypted transactions on SKALE"
---

<Note>
Typescript transpiles to JavaScript. The SDK is compatible with both JavaScript and Typescript in both Node.js, Bun, and browser environments.
If you have any issues, please join us in [Discord](https://discord.gg/skale) to report the problem or open an issue on [GitHub](https://github.com/skalenetwork/bite-ts).
</Note>

## Using the SDK

The BITE JavaScript SDK enables application and wallet developers to encrypt EVM transactions. BITE extends SKALE's provably secure consensus protocol with threshold encryption, allowing developers to build private and confidential applications on SKALE.

### Installation

```bash
# npm
npm i @skalenetwork/bite

# yarn
yarn add @skalenetwork/bite

# pnpm
pnpm add @skalenetwork/bite

# Bun
bun add @skalenetwork/bite
```

<Note>
The SDK works with any BITE-enabled SKALE chain. Currently, BITE is available on [SKALE Base Mainnet and Testnet](/get-started/quick-start/skale-on-base) ONLY.
</Note>

### Quick Start

```typescript
import { BITE } from '@skalenetwork/bite';

const providerUrl = 'https://your-fair-rpc';
const bite = new BITE(providerUrl);

// Minimal tx object: encrypts `to` and `data` and rewrites `to` to BITE magic address
const tx = {
  to: '0x1234567890abcdef1234567890abcdef12345678',
  data: '0x1234abcd',
};

const encryptedTx = await bite.encryptTransaction(tx);
// send via your wallet / provider, e.g. 
window.ethereum.request({ method: 'eth_sendTransaction', params: [encryptedTx] })

// Later, fetch revealed original fields after block finality
const result = await bite.getDecryptedTransactionData('<txHash>');
// result => { to: '0x...', data: '0x...' }
```

## API Reference

### `new BITE(endpoint)`

Creates a new BITE instance configured to use a specific BITE JSON-RPC endpoint.

**Parameters:**
- `endpoint: string` – BITE URL provider (JSON-RPC endpoint)

**Example:**
```typescript
const bite = new BITE('https://your-skale-chain.skale.network');
```

### `bite.encryptTransaction(tx)`

Encrypts a transaction object using the BLS threshold encryption public key(s) from the configured BITE provider. The encrypted transaction will have its `to` field set to the BITE magic address.

**Parameters:**
- `tx: { to: string; data: string; /* optional gas and other fields */ }` – Standard hex strings

**Returns:** `Promise<Transaction>` – Encrypted params safe to submit to `eth_sendTransaction`

<Warning>
When passing a transaction to `bite.ts`, it is necessary to set the gasLimit field manually. This is because estimateGas does not return a proper value for encrypted transactions. If gasLimit is omitted, `bite.ts` will automatically set it to **300000**.
</Warning>

**Encryption Process:**
1. RLP encodes the original `data` and `to` fields
2. Encrypts the encoded data using AES with a randomly generated key
3. Encrypts the AES key using BLS threshold encryption
4. Creates the final payload in RLP format: `[EPOCH_ID, ENCRYPTED_BITE_DATA]`

### `bite.encryptMessage(message)`

Encrypts a raw hex-encoded message using the BLS threshold encryption from the configured BITE provider.

**Parameters:**
- `message: string` – A hex string to encrypt (with or without `0x` prefix)

**Returns:** `Promise<string>` – An encrypted hex string in RLP format with epoch and encryption data

**Example:**
```typescript
const encryptedMessage = await bite.encryptMessage('0x48656c6c6f20576f726c64'); // "Hello World"
console.log('Encrypted:', encryptedMessage);
```

### `bite.getDecryptedTransactionData(transactionHash)`

Retrieves decrypted transaction data from the configured BITE provider using the `bite_getDecryptedTransactionData` JSON-RPC method.

**Parameters:**
- `transactionHash: string` – The transaction hash to decrypt

**Returns:** `Promise<object>` – JSON object with `data` and `to` keys containing the original decrypted fields

**Example:**
```typescript
const decryptedData = await bite.getDecryptedTransactionData('0x1234...abcd');
console.log('Original to:', decryptedData.to);
console.log('Original data:', decryptedData.data);
```

<Note>
This method only works for BITE transactions that have been processed and decrypted by the consensus. If the transaction doesn't exist or has no decrypted data, an error is thrown.
</Note>

### `bite.getCommitteesInfo()`

Fetches committee information from the configured BITE provider using the `bite_getCommitteesInfo` JSON-RPC method.

**Returns:** `Promise<Array>` – An array of 1-2 JSON objects, each containing:
- `commonBLSPublicKey`: A 256-character hex string (128-byte BLS public key)
- `epochId`: An integer representing the epoch identifier

**Array Contents:**
- **1 element**: During normal operation (single active committee)
- **2 elements**: During committee rotation periods (scheduled for next 3 minutes)

**Example:**
```typescript
const committeesInfo = await bite.getCommitteesInfo();
console.log('Current BLS Public Key:', committeesInfo[0].commonBLSPublicKey);
console.log('Current Epoch ID:', committeesInfo[0].epochId);

if (committeesInfo.length === 2) {
    console.log('Rotation in progress - dual encryption active');
}
```

## Integration Examples

```typescript MetaMask
import { BITE } from '@skalenetwork/bite';

const bite = new BITE('https://your-skale-chain.skale.network');

async function sendEncryptedTransaction(to, data) {
    const tx = { to, data };
    const encryptedTx = await bite.encryptTransaction(tx);
    
    const txHash = await window.ethereum.request({
        method: 'eth_sendTransaction',
        params: [encryptedTx],
    });
    
    return txHash;
}
```

```typescript Ethers.js
import { BITE } from '@skalenetwork/bite';
import { ethers } from 'ethers';

const bite = new BITE('https://your-skale-chain.skale.network');
const provider = new ethers.BrowserProvider(window.ethereum);
const signer = await provider.getSigner();

async function sendEncryptedERC20Transfer(tokenAddress, to, amount) {
    const iface = new ethers.Interface([
        'function transfer(address to, uint256 amount)'
    ]);
    const data = iface.encodeFunctionData('transfer', [to, amount]);
    
    const tx = { to: tokenAddress, data };
    const encryptedTx = await bite.encryptTransaction(tx);
    
    const txResponse = await signer.sendTransaction(encryptedTx);
    return txResponse.hash;
}
```

## Best Practices

### Gas Limit Management

<Warning>
Always set a proper gas limit for encrypted transactions. Do not rely on `estimateGas()` as it doesn't work correctly with encrypted payloads.
</Warning>

```typescript
// Bad - will use default 300000 gas
const encryptedTx = await bite.encryptTransaction(tx);

// Good - set appropriate gas limit
const tx = {
    to: '0x...',
    data: '0x...',
    gasLimit: 200000, // Set appropriate limit for your transaction
};
const encryptedTx = await bite.encryptTransaction(tx);
```



### Monitoring Committee Changes

```typescript

const INTERVAL_MS = 30000; // 30 seconds

// Check for upcoming committee rotations
async function monitorCommitteeRotation() {
    const committees = await bite.getCommitteesInfo();
    
    if (committees.length === 2) {
        console.warn('Committee rotation in progress - dual encryption active');
        // Implement rotation-specific logic if needed
    }
    
    // Schedule periodic checks
    setTimeout(monitorCommitteeRotation, INTERVAL_MS);
}
```

<Note>
This is not a requirement for single use encrypted transactions. If you are building with Conditional Transactions, you can optionally monitor committee changes to handle expiration of a conditional transaction which can occur during 
</Note>

## BITE V2

BITE V2 extends BITE V1 by enabling smart contracts to store encrypted data and request decryption directly from within Solidity and the EVM. While BITE V1 focuses on encrypting transaction payloads for privacy, BITE V2 introduces Conditional Transactions (CTXs) — transactions initiated by smart contracts in one block and executed in the next block with decrypted data.

### Example: Simple Game with CTXs

The following demo showcases a simple game that demonstrates BITE V2's core capability: encrypting data off-chain, submitting it to a smart contract, and then having the contract request decryption and execute logic on the revealed values in a subsequent block.

**Game flow:** 
1. The user submits encrypted numbers and plaintext numbers to the contract. 
2. The contract then calls `decryptAndExecute()`, which creates a Conditional Transaction (CTX).
3. In the next block, the encrypted values are decrypted by the SKALE consensus and delivered to the contract's `onDecrypt()` callback, where the game logic calculates the sums and determines if the user won (difference between sums < 101).

### Prerequisites

- Ensure you have the latest [BITE SDK installed](#using-the-sdk).

### Smart Contract

Create a file named `Game.sol` with the following contract:
<Note>
If any question on how to deploy a contract please visit the [cookbook](/cookbook/deployment/setup-foundry)
</Note>

```solidity
pragma solidity 0.8.20;

contract Game {
    bytes[] plaintext;
    bytes[] encrypted;
    bool userWon = false;
    uint256 sumDecryptedTotal = 0;
    constructor() payable {}

    function submitEncrypted(bytes calldata _encrypted) public {
        encrypted.push(_encrypted);
    }

    function submitPlaintext(bytes calldata _plaintext) public {
        plaintext.push(_plaintext);
    }

    function decryptAndExecute() public {
        uint256 randomNumber = uint256(keccak256(abi.encodePacked(block.timestamp, block.number))) % 2500000 + 1000000;
        bytes memory randomBytes = abi.encode(encrypted, plaintext);
        bytes memory input = abi.encode(randomNumber, randomBytes);

        (bool success, bytes memory result) = address(0x1b).staticcall(input);
        require(success, "0x1b call failed");

        // Extract address from first 20 bytes of result and transfer
        address walletAddress = address(bytes20(result));
        payable(walletAddress).transfer(448384400000);
    }

    function onDecrypt(bytes[] calldata decryptedArguments, bytes[] calldata plaintextArguments) public {
        uint256 sumPlaintext = 0;
        for (uint256 i = 0; i < plaintextArguments.length; ++i) {
            sumPlaintext += abi.decode(plaintextArguments[i], (uint256));
        }
        uint256 sumDecrypted = 0;
        for (uint256 i = 0; i < decryptedArguments.length; ++i) {
            sumDecrypted += abi.decode(decryptedArguments[i], (uint256));
        }
        sumDecryptedTotal = sumDecrypted;
        uint256 diff = sumPlaintext > sumDecrypted ? sumPlaintext - sumDecrypted : sumDecrypted - sumPlaintext;
        userWon = diff < 101;
    }

    function didUserWin() public view returns (bool) {
        return userWon;
    }

    function getSumDecrypted() public view returns (uint256) {
        return sumDecryptedTotal;
    }
}
```

### Test Script

Create a TypeScript file named `run-game.ts` to interact with the contract:

```typescript
import { BITE } from "@skalenetwork/bite"
import { Contract, JsonRpcProvider, Wallet, ContractFactory } from "ethers"
import GameJson from "./out/Game.sol/Game.json";

const providerUrl = "https://base-sepolia-testnet.skalenodes.com/v1/bite-v2-sandbox-2"
const INSECURE_ETH_PRIVATE_KEY = "0x..."; // Replace with your private key

const ABI = GameJson.abi;
const bytecode = GameJson.bytecode;

async function runSampleBITE2() {
    // Initialize provider and signer
    const provider = new JsonRpcProvider(providerUrl);
    const signer = new Wallet(INSECURE_ETH_PRIVATE_KEY, provider);
    const bite = new BITE(providerUrl);

    // Deploy the contract
    console.log("Step 1: Deploying smart contract...");
    const factory = new ContractFactory(ABI, bytecode, signer);
    const deployedContract = await factory.deploy({ value: BigInt(1_000_000_000_000_000_000) });
    await deployedContract.waitForDeployment();
    const contractAddress = await deployedContract.getAddress();
    console.log(`Contract deployed at: ${contractAddress}\n`);

    const contract = new Contract(contractAddress, ABI, signer);

    // Generate and submit encrypted numbers
    console.log("Step 2: Submitting encrypted data...");
    const encryptedNumbers = [];
    for (let i = 0; i < 5; i++) {
        const num = Math.floor(Math.random() * 200) + 50;
        encryptedNumbers.push(num);
        const hexValue = '0x' + num.toString(16).padStart(64, '0');
        const encryptedNumber = await bite.encryptMessage(hexValue);
        await contract.submitEncrypted(encryptedNumber);
    }
    console.log(`Encrypted numbers: ${encryptedNumbers.join(', ')}\n`);

    // Generate and submit plaintext numbers
    console.log("Step 3: Submitting plaintext data...");
    const plaintextNumbers = [];
    for (let i = 0; i < 5; i++) {
        const num = Math.floor(Math.random() * 200) + 50;
        plaintextNumbers.push(num);
        const hexValue = '0x' + num.toString(16).padStart(64, '0');
        await contract.submitPlaintext(hexValue);
    }
    console.log(`Plaintext numbers: ${plaintextNumbers.join(', ')}\n`);

    // Trigger decryption via CTX
    console.log("Step 4: Calling decryptAndExecute...");
    const decryptTx = await contract.decryptAndExecute({ gasLimit: 5000000 });
    await decryptTx.wait();

    // Wait for next block (where onDecrypt executes)
    const currentBlock = await provider.getBlockNumber();
    let nextBlock = currentBlock;
    while (nextBlock <= currentBlock) {
        await new Promise(resolve => setTimeout(resolve, 1000));
        nextBlock = await provider.getBlockNumber();
    }

    // Verify results
    console.log("Step 5: Verifying results...");
    const decryptedSum = await contract.getSumDecrypted();
    const didWin = await contract.didUserWin();
    console.log(`Decrypted sum: ${decryptedSum}`);
    console.log(`Result: ${didWin ? 'WON!' : 'LOST'}`);
}

runSampleBITE2().catch(console.error);
```

### Running the Example

To run the game script:

```bash
bun run run-game.ts
```

<Note>
This example uses the BITE V2 Sandbox 2. Ensure your wallet has sufficient sFUEL for gas before running.
</Note>
<Tip>
For more complex BITE V2 demos please visit the cookbook.
</Tip>

## Resources

- **Repository**: [https://github.com/skalenetwork/bite-ts](https://github.com/skalenetwork/bite-ts)
- **How BITE Works**: [How BITE Works](/developers/bite-protocol/how-bite-works)
- **MEV Protection**: [MEV Deep Dive](/concepts/bite-protocol/mev-deep-dive)
- **Tutorial**: [Sending Encrypted Transactions with BITE](/cookbook/privacy/sending-encrypted-transactions-with-bite)