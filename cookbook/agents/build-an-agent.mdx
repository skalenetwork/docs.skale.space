---
title: "Build an Agent"
description: "Build AI agents that interact with onchain data, make payments, and access paywalled resources"
---

## Build an Agent

Build agents that can autonomously interact with APIs, make x402 payments, and access paywalled resources. This guide covers two approaches: a basic agent for simple use cases and an AI-powered agent using LangChain for more complex decision-making.

## Prerequisites

- Node.js and npm installed
- A SKALE Chain endpoint
- Understanding of x402 protocol (see [Make Payments](/cookbook/x402/buying))
- Familiarity with TypeScript/JavaScript
- A wallet with funds (USDC or supported token)
- OpenAI API key (for LangChain agent)

## Overview

| Agent Type | Best For |
|------------|----------|
| **Basic Agent** | Simple automation, scripts, scheduled tasks |
| **LangChain Agent** | AI-powered decisions, natural language interaction, complex workflows |

---

## Implementation

<Tabs>
    <Tab title="Basic Agent">

        A basic agent handles x402 payments programmatically without AI. Perfect for automated scripts, bots, or services that need to access paywalled resources.

        ### Step 1: Install Dependencies

        ```bash
        npm install @x402/core @x402/evm viem dotenv
        ```

        ### Step 2: Set Up Environment Variables

        Create a `.env` file:

        ```bash
        # Your wallet private key (never commit this!)
        PRIVATE_KEY=0xYourPrivateKey

        # USDC token contract on SKALE
        PAYMENT_TOKEN_ADDRESS=0x2e08028E3C4c2356572E096d8EF835cD5C6030bD
        PAYMENT_TOKEN_NAME="Bridged USDC (SKALE Bridge)"
        ```

        ### Step 3: Define Your Chain

        Create a file `chain.ts`:

        ```typescript
        import { defineChain } from "viem";

        export const skaleChain = defineChain({
            id: 324705682,
            name: "SKALE Base Sepolia",
            nativeCurrency: { decimals: 18, name: "Credits", symbol: "CREDIT" },
            rpcUrls: {
                default: { http: ["https://base-sepolia-testnet.skalenodes.com/v1/base-testnet"] },
            },
        });
        ```

        ### Step 4: Create the Agent Class

        Create a file `agent.ts`:

        ```typescript
        import { x402Client, x402HTTPClient } from "@x402/core/client";
        import { ExactEvmScheme } from "@x402/evm";
        import { privateKeyToAccount } from "viem/accounts";
        import { createPublicClient, http, formatEther } from "viem";
        import { skaleChain } from "./chain";
        import "dotenv/config";

        type AccessResult = {
            success: boolean;
            data?: unknown;
            error?: string;
        };

        class BasicAgent {
            private httpClient: x402HTTPClient;
            private walletAddress: string;
            private publicClient: ReturnType<typeof createPublicClient>;

            private constructor(
                httpClient: x402HTTPClient,
                walletAddress: string,
                publicClient: ReturnType<typeof createPublicClient>
            ) {
                this.httpClient = httpClient;
                this.walletAddress = walletAddress;
                this.publicClient = publicClient;
            }

            static async create(): Promise<BasicAgent> {
                const privateKey = process.env.PRIVATE_KEY;
                if (!privateKey) {
                    throw new Error("PRIVATE_KEY environment variable is required");
                }

                // Create wallet account from private key
                const account = privateKeyToAccount(privateKey as `0x${string}`);

                // Create EVM scheme for signing payments
                const evmScheme = new ExactEvmScheme(account);

                // Register scheme for all EVM networks
                const coreClient = new x402Client().register("eip155:*", evmScheme);
                const httpClient = new x402HTTPClient(coreClient);

                // Create public client for balance checks
                const publicClient = createPublicClient({
                    chain: skaleChain,
                    transport: http(),
                });

                console.log(`Agent initialized with wallet: ${account.address}`);

                return new BasicAgent(httpClient, account.address, publicClient);
            }

            async accessResource(url: string): Promise<AccessResult> {
                console.log(`Accessing resource: ${url}`);

                try {
                    const response = await fetch(url, {
                        method: "GET",
                        headers: { "Content-Type": "application/json" },
                    });

                    if (response.status === 402) {
                        return this.handlePaymentRequired(response, url);
                    }

                    if (!response.ok) {
                        return { success: false, error: `Request failed: ${response.status}` };
                    }

                    const data = await response.json();
                    return { success: true, data };
                } catch (error) {
                    const message = error instanceof Error ? error.message : "Unknown error";
                    return { success: false, error: message };
                }
            }

            private async handlePaymentRequired(
                response: Response,
                url: string
            ): Promise<AccessResult> {
                console.log("Payment required (402), processing payment...");

                try {
                    const responseBody = await response.json();

                    // Get payment requirements from response headers and body
                    const paymentRequired = this.httpClient.getPaymentRequiredResponse(
                        (name: string) => response.headers.get(name),
                        responseBody
                    );

                    console.log(`Payment options: ${paymentRequired.accepts.length}`);

                    // Create signed payment payload
                    const paymentPayload = await this.httpClient.createPaymentPayload(paymentRequired);

                    // Encode payment headers for the retry request
                    const paymentHeaders = this.httpClient.encodePaymentSignatureHeader(paymentPayload);

                    // Retry request with payment
                    const paidResponse = await fetch(url, {
                        method: "GET",
                        headers: {
                            "Content-Type": "application/json",
                            ...paymentHeaders,
                        },
                    });

                    if (!paidResponse.ok) {
                        return { success: false, error: `Payment failed: ${paidResponse.status}` };
                    }

                    // Check settlement response
                    const settlement = this.httpClient.getPaymentSettleResponse(
                        (name: string) => paidResponse.headers.get(name)
                    );

                    if (settlement?.transaction) {
                        console.log(`Payment settled, tx: ${settlement.transaction}`);
                    }

                    const data = await paidResponse.json();
                    console.log("Resource accessed successfully after payment!");
                    return { success: true, data };
                } catch (error) {
                    const message = error instanceof Error ? error.message : "Unknown error";
                    console.error("Payment processing failed:", message);
                    return { success: false, error: message };
                }
            }

            getAddress(): string {
                return this.walletAddress;
            }

            async getBalance(): Promise<string> {
                const balance = await this.publicClient.getBalance({
                    address: this.walletAddress as `0x${string}`,
                });
                return formatEther(balance);
            }
        }

        export default BasicAgent;
        ```

        ### Step 5: Use the Agent

        Create a file `index.ts`:

        ```typescript
        import BasicAgent from "./agent";

        async function main() {
            // Create the agent (async factory pattern)
            const agent = await BasicAgent.create();

            console.log(`Agent wallet: ${agent.getAddress()}`);
            console.log(`Balance: ${await agent.getBalance()} sFUEL`);
            console.log("---");

            // Access a paywalled resource
            const result = await agent.accessResource("http://localhost:3000/premium/data");

            if (result.success) {
                console.log("Received data:", result.data);
            } else {
                console.error("Error:", result.error);
            }
        }

        main().catch(console.error);
        ```

        ### Step 6: Run the Agent

        ```bash
        npx tsx index.ts
        ```

    </Tab>
    <Tab title="LangChain Agent">

        An AI-powered agent uses LangChain to make intelligent decisions about when and how to access paywalled resources. The agent can understand natural language requests and autonomously decide to make payments.

        ### Step 1: Install Dependencies

        ```bash
        npm install @coinbase/x402-sdk ethers dotenv @langchain/openai langchain @langchain/core
        ```

        ### Step 2: Set Up Environment Variables

        Create a `.env` file:

        ```bash
        PRIVATE_KEY=your_wallet_private_key
        SKALE_RPC_URL=https://testnet.skalenodes.com/v1/juicy-low-small-testnet
        FACILITATOR_URL=https://facilitator.dirtroad.dev
        OPENAI_API_KEY=your_openai_api_key
        ```

        ### Step 3: Create the Payment Tool

        LangChain agents use "tools" to perform actions. We'll create a tool that handles x402 payments:

        Create a file `tools/payment-tool.ts`:

        ```typescript
        import { X402Client } from '@coinbase/x402-sdk';
        import { ethers } from 'ethers';
        import { DynamicTool } from '@langchain/core/tools';

        export function createPaymentTool(wallet: ethers.Wallet, facilitatorURL: string) {
            const x402Client = new X402Client({
                wallet: wallet,
                facilitatorURL: facilitatorURL,
            });

            return new DynamicTool({
                name: 'access_paywalled_resource',
                description: 'Access a paywalled resource by making an x402 payment. Use this when you need to fetch data from a URL that requires payment. Input should be the full URL.',
                func: async (url: string) => {
                    try {
                        console.log(`[Payment Tool] Accessing: ${url}`);
                        
                        const response = await fetch(url);
                        
                        if (response.status === 402) {
                            console.log('[Payment Tool] Payment required, processing...');
                            
                            const paymentInfo = await response.json();
                            const payment = await x402Client.createPayment(paymentInfo);
                            await x402Client.settle(payment);
                            
                            const retryResponse = await fetch(url, {
                                headers: { 'X-PAYMENT': JSON.stringify(payment) },
                            });
                            
                            const data = await retryResponse.json();
                            console.log('[Payment Tool] Payment successful!');
                            return JSON.stringify(data);
                        }
                        
                        const data = await response.json();
                        return JSON.stringify(data);
                    } catch (error) {
                        return `Error accessing resource: ${error}`;
                    }
                },
            });
        }
        ```

        ### Step 4: Create the AI Agent

        Create a file `langchain-agent.ts`:

        ```typescript
        import { ChatOpenAI } from '@langchain/openai';
        import { AgentExecutor, createOpenAIFunctionsAgent } from 'langchain/agents';
        import { ChatPromptTemplate, MessagesPlaceholder } from '@langchain/core/prompts';
        import { ethers } from 'ethers';
        import { createPaymentTool } from './tools/payment-tool';
        import 'dotenv/config';

        class LangChainAgent {
            private agentExecutor: AgentExecutor;
            private wallet: ethers.Wallet;

            constructor() {
                // Initialize wallet
                const provider = new ethers.JsonRpcProvider(process.env.SKALE_RPC_URL);
                this.wallet = new ethers.Wallet(process.env.PRIVATE_KEY!, provider);
                
                console.log(`Agent initialized with wallet: ${this.wallet.address}`);
            }

            async initialize() {
                // Create the payment tool
                const paymentTool = createPaymentTool(
                    this.wallet,
                    process.env.FACILITATOR_URL!
                );

                // Initialize the LLM
                const llm = new ChatOpenAI({
                    modelName: 'gpt-4',
                    temperature: 0,
                });

                // Create the prompt template
                const prompt = ChatPromptTemplate.fromMessages([
                    ['system', `You are a helpful AI agent that can access paywalled resources on behalf of the user. 
                    
When the user asks for data from a paywalled API, use the access_paywalled_resource tool to fetch it.
Always provide a clear summary of the data you retrieve.
If there's an error, explain what went wrong.`],
                    ['human', '{input}'],
                    new MessagesPlaceholder('agent_scratchpad'),
                ]);

                // Create the agent
                const agent = await createOpenAIFunctionsAgent({
                    llm,
                    tools: [paymentTool],
                    prompt,
                });

                // Create the executor
                this.agentExecutor = new AgentExecutor({
                    agent,
                    tools: [paymentTool],
                    verbose: true, // Set to false in production
                });

                console.log('Agent ready!');
            }

            /**
             * Process a natural language request
             */
            async chat(message: string): Promise<string> {
                const result = await this.agentExecutor.invoke({
                    input: message,
                });
                
                return result.output;
            }

            getAddress(): string {
                return this.wallet.address;
            }
        }

        export default LangChainAgent;
        ```

        ### Step 5: Use the Agent

        Create a file `index.ts`:

        ```typescript
        import LangChainAgent from './langchain-agent';
        import * as readline from 'readline';

        async function main() {
            // Create and initialize the agent
            const agent = new LangChainAgent();
            await agent.initialize();
            
            console.log(`\nWallet: ${agent.getAddress()}`);
            console.log('Agent is ready! Type your requests below.\n');

            // Create interactive prompt
            const rl = readline.createInterface({
                input: process.stdin,
                output: process.stdout,
            });

            const askQuestion = () => {
                rl.question('You: ', async (input) => {
                    if (input.toLowerCase() === 'exit') {
                        rl.close();
                        return;
                    }

                    try {
                        const response = await agent.chat(input);
                        console.log(`\nAgent: ${response}\n`);
                    } catch (error) {
                        console.error('Error:', error);
                    }

                    askQuestion();
                });
            };

            askQuestion();
        }

        main().catch(console.error);
        ```

        ### Step 6: Run the Agent

        ```bash
        npx ts-node index.ts
        ```

        Example interaction:

        ```
        You: Get me the premium weather data from https://api.example.com/premium/weather
        
        [Payment Tool] Accessing: https://api.example.com/premium/weather
        [Payment Tool] Payment required, processing...
        [Payment Tool] Payment successful!
        
        Agent: I retrieved the weather data for you. Here's the summary:
        - Temperature: 72Â°F
        - Humidity: 45%
        - Forecast: Sunny with clear skies
        ```

        ### Complete Working Example

        Here's a simplified single-file version:

        ```typescript
        import { X402Client } from '@coinbase/x402-sdk';
        import { ChatOpenAI } from '@langchain/openai';
        import { AgentExecutor, createOpenAIFunctionsAgent } from 'langchain/agents';
        import { ChatPromptTemplate, MessagesPlaceholder } from '@langchain/core/prompts';
        import { DynamicTool } from '@langchain/core/tools';
        import { ethers } from 'ethers';
        import 'dotenv/config';

        async function main() {
            // Setup wallet
            const provider = new ethers.JsonRpcProvider(process.env.SKALE_RPC_URL);
            const wallet = new ethers.Wallet(process.env.PRIVATE_KEY!, provider);
            
            // Setup x402 client
            const x402Client = new X402Client({
                wallet: wallet,
                facilitatorURL: process.env.FACILITATOR_URL!,
            });

            // Create payment tool
            const paymentTool = new DynamicTool({
                name: 'access_paywalled_resource',
                description: 'Access a paywalled resource by making an x402 payment. Input: URL',
                func: async (url: string) => {
                    const response = await fetch(url);
                    
                    if (response.status === 402) {
                        const paymentInfo = await response.json();
                        const payment = await x402Client.createPayment(paymentInfo);
                        await x402Client.settle(payment);
                        
                        const retryResponse = await fetch(url, {
                            headers: { 'X-PAYMENT': JSON.stringify(payment) },
                        });
                        
                        return JSON.stringify(await retryResponse.json());
                    }
                    
                    return JSON.stringify(await response.json());
                },
            });

            // Setup LLM and agent
            const llm = new ChatOpenAI({ modelName: 'gpt-4', temperature: 0 });
            
            const prompt = ChatPromptTemplate.fromMessages([
                ['system', 'You are a helpful AI agent that can access paywalled resources.'],
                ['human', '{input}'],
                new MessagesPlaceholder('agent_scratchpad'),
            ]);

            const agent = await createOpenAIFunctionsAgent({ llm, tools: [paymentTool], prompt });
            const executor = new AgentExecutor({ agent, tools: [paymentTool] });

            // Chat with the agent
            const result = await executor.invoke({
                input: 'Get me data from https://api.example.com/premium/data',
            });

            console.log('Agent response:', result.output);
        }

        main().catch(console.error);
        ```

    </Tab>
</Tabs>

---

## Best Practices

1. **Set Spending Limits**: Implement maximum payment amounts to prevent unexpected costs
2. **Use Environment Variables**: Never hardcode private keys or API keys
3. **Log Transactions**: Keep records of all payments for debugging and accounting
4. **Handle Errors Gracefully**: Always wrap payment logic in try-catch blocks
5. **Test on Testnet First**: Use SKALE testnet before deploying to production

## Security Considerations

- Never expose private keys in client-side code or logs
- Use secure key management (environment variables, secrets manager)
- Implement rate limiting to prevent abuse
- Consider using a dedicated wallet with limited funds for agents
- Audit your agent's behavior regularly

## Next Steps

- [Accept Payments (Seller)](/cookbook/x402/accepting-payments)
- [Run a Facilitator](/cookbook/x402/facilitator)
- [Multi-Token Payments](/cookbook/x402/non-usdc-tokens)

## Resources

- [AI Agents Use Case](/get-started/use-cases/ai-agents)
- [Coinbase x402 Examples](https://github.com/coinbase/x402/tree/main/examples/typescript/dynamic_agent)
- [LangChain Documentation](https://js.langchain.com/docs)
- [x402 Examples Repository](https://github.com/TheGreatAxios/x402-examples)
